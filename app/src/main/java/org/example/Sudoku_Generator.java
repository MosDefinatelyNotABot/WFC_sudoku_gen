/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Random;
import java.io.File;
import java.io.FileWriter;

public class Sudoku_Generator implements Runnable {
    /*
     * we generate a sudoku puzzle using a method roughly inspired by
     * wave function collapse. At first every block can be any number
     * from 1 to 9. We keep track of each block's entropy and then
     * randomly pick a block and assign it a value. We update the
     * entropy table. Then we pick the block with lowest entropy and
     * repeat.
     */

    public Sudoku puzzle;
    private Random RNG;
    private int id;

    public Sudoku_Generator(int id) {
        // setup the puzzle with a seed
        this.puzzle = new Sudoku();
        this.RNG = new Random();
        this.id = id;
    }

    public Sudoku_Generator(int id, Random RNG) {
        // setup the puzzle with a seed
        this.puzzle = new Sudoku();
        this.RNG = RNG;
        this.id = id;
    }

    public Sudoku_Generator(int id, int seed) {
        // setup the puzzle with a seed
        this.puzzle = new Sudoku();
        this.RNG = new Random(seed);
        this.id = id;
    }

    @Override
    public void run() {

        // pick a random row, col and number
        int curr_row = this.RNG.nextInt(9);
        int curr_col = this.RNG.nextInt(9);
        int curr_val = this.RNG.nextInt(9) + 1;

        puzzle.setNum(curr_row, curr_col, curr_val);

        // setup the entropy table
        Entropy_Table ent_table = new Entropy_Table(this.puzzle);

        // iterate over the puzzle
        while (!ent_table.table.isEmpty()) {
            update_puzzle(ent_table);
        }

        if (ent_table.num_empty != 0) {
            // if we produced a bad puzzle, start over
            // System.out.println(this.puzzle);
            this.puzzle = new Sudoku();
            run();
        } else {
            // otherwise print to console and save to json
            System.out.println(this.puzzle);
            print_to_json(this.puzzle);
        }

    }

    public void update_puzzle(Entropy_Table ent_table) {
        // recursive function to collapse block values

        while (ent_table.table.size() != 0) {
            // while the entropy table is not empty get the top entry

            Entropy next_block = ent_table.table.get(0);

            // System.out.println(ent_table.table.toString());
            // System.out.println(ent_table.num_empty);
            // get the values for this block
            int curr_row = next_block.get_row();
            int curr_col = next_block.get_col();
            int curr_val = next_block.get_ran_value(RNG);

            // set the values and update the entropy table
            this.puzzle.setNum(curr_row, curr_col, curr_val);
            ent_table.table.remove(next_block); // remove the entropy entry
            ent_table.update_table(this.puzzle);
        }

    }

    void print_to_json(Sudoku puzzle) {
        // print row by row to a json file.
        try {
            FileWriter fw = new FileWriter(new File("output_puzzles/puzzle_" + id + ".json"));

            fw.write("{\n");

            for (int i = 0; i < 9; i++) {
                fw.append("\t\"row" + i + "\": [");

                int[] row = puzzle.getRow(i);

                for (int j = 0; j < 9; j++) {
                    if (j == 8) {
                        fw.write(row[j] + "]");
                        if (i != 8) {
                            fw.write(",\n");
                        }
                    } else {
                        fw.write(row[j] + ",");
                    }
                }
            }

            fw.write("\n}");
            fw.close();

        } catch (Exception e) {
            System.err.println("IO error :(");
            e.printStackTrace();
        }
    }

}
